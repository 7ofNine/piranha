- Fix perf. issues in TASSr6 by disabling coded arithmetics for short series
- Fix unnecessarily long series in binomial expansion for pow (maybe fixed with exponentiation by squaring?)
- Use reference counted pointer to psymbols to make them live only as necessary?
- Move meta-programming in base_series_* into own headers to improve readability.
- Poisson and poly multiplier: truncator calls also when inserting terms for generality.
- GMP limb: " A limb means the part of a multi-precision number that fits in a single word.
  Normally a limb contains 32 or 64 bits. The C data type for a limb is mp_limb_t.". Use this
  to evaluate the real size of GMP variables when we will do cache-blocking during multiplications.
  http://gmplib.org/manual/Integer-Special-Functions.html#Integer-Special-Functions
- Add line - file info into exceptions string.
- Coded multiplication with mpz as codes when going out of range?
- elements_* --> ints_* in int_array for clarity
- int_array --> key_int_array for clarity
- there _is_ a mpz_swap function, check if it is useful.
- understand the relation between ordering and vector coded performance. For polynomials it increases performance
  a total degree lex order, for poisson series it _seems_ no --> this probably has to do with prefetching, which is destroyed
  in poisson series because of the additional subtraction on the index of the vector. This can be probably optimized
  for poisson series somehow.
- optimize for small series --> there's no need to avoid direct insertion in series, since we do
  not have sorted indices anymore. For small series, also avoid all the re-sorting and possible coefficient
  copies that are performed for longer series?
- TRIM
- Share the implementation of filter in C++ and python using virtual function ovverride?
- Uniform naming scheme in C++ and python.
- Use wrappers everywhere for the exposition of functionality in python.
- tc class --> see if it is effective to perform the evaluations in C++ (possibly using parallelization), then applying the
  function in python using numpy (supposedly fast) array classes.
- Watch out for trim! We do not want to ever get it called into the anonymous interface, because it could mess up badly
  the relation with the provided args_tuple. Make sure that the named interface is _never_ used inside the anonymous one.
- maybe proxies should take an args_tuple in the ctor. This way we can avoid the cached* flags in them - Yes, but caching may
  have a non-negligible cost. Must do speed test.
- speed test for hash coded implementation.
- addmul for coefficient series. This probably requires moving the ignorability check higher in the insert function stack.
- series splicing?
- limit for multiplication time?
- Move "using base_*" into private space of top-level series?
- Generalise conversion to/from series with arguments sets left/right shifting
- Check those complex changes and the static cast on root(y).
- Use this-> instead of ancestor:: everywhere?
- Place boost::operators in some shared toolbox?
- Compile with -D_PIRANHA_DEBUG as default?
- Another interface for Ynm, this time with theta as a complex thingie representing the complex exponential of colatitude?
- Drop all typename Derived::term_type
- check that truncators do not sort if not necessary.
- for hash coded structure, use directly the counting allocator internally.
- direct calculation of special functions and celmec expansions - psym interface from celmec functions should be dropped
  maybe and auto-detect series that consist of a single symbol --> use faster approach there.
- Try murmurhash.
- Take care of allocation of zero-size memory areas?
- Boost's aligned storage type traits for sse?
- Write tests also in python.
- Provide interface to int and long int instead of just max_fast_int? Interop with int and long int
  instead of max_fast_int.
- Dispatch complicated functions of single-cf series to the coefficient. This way we can re-use faster implementations
  (e.g., polynomial coefficients in Poisson series).
- Unify insert functions, possibly dropping the dangerous "check" bool param (but check performance first). Also, probably
  the insert range flavour can be used extensively in complex toolboxes.
- Drop ctor from generic cf and key for terms in favour of explicit constructor from proxies?
- Should "a.real = 10" be allowed in pyranha?
- rehash --> prepare_for_size and fast insert that won't check for duplicate item? This may be useful to cut down
  the insertion time after series multiplication finishes, and requires our own hash table implementation. Fast insertion
  should be protected and then friendship should be made with the multiplier --> this does not seem to work, alas.
- rework the type-determination thing (tetd_helper and stuff) to be less ugly.
- watch out: when building base series from pod we may be doing term insertion somewhere instead of using the ctor.
  Search and de-uglify if needed.
