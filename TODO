- Fix perf. issues in TASSr6 by disabling coded arithmetics for short series
- Fix unnecessarily long series in binomial expansion for pow (maybe fixed with exponentiation by squaring?)
- Use reference counted pointer to psymbols to make them live only as necessary?
- Unify stream_manager and settings?
- Move meta-programming in base_series_* into own headers to improve readability.
- Poisson and poly multiplier: truncator calls also when inserting terms for generality.
- GMP limb: " A limb means the part of a multi-precision number that fits in a single word.
  Normally a limb contains 32 or 64 bits. The C data type for a limb is mp_limb_t.". Use this
  to evaluate the real size of GMP variables when we will do cache-blocking during multiplications.
  http://gmplib.org/manual/Integer-Special-Functions.html#Integer-Special-Functions
- Add line - file info into exceptions string.
- Coded multiplication with mpz as codes when going out of range?
- elements_* --> ints_* in int_array for clarity
- int_array --> key_int_array for clarity
- there _is_ a mpz_swap function, check if it is useful.
- understand the relation between ordering and vector coded performance. For polynomials it increases performance
  a total degree lex order, for poisson series it _seems_ no --> this probably has to do with prefetching, which is destroyed
  in poisson series because of the additional subtraction on the index of the vector. This can be probably optimized
  for poisson series somehow.
- find a method to establish how to cache a coefficient vector during multiplication if appropriate.
- optimize for small series --> there's no need to avoid direct insertion in series, since we do
  not have sorte indices anymore. For small series, also avoid all the re-sorting and possible coefficient
  copies that are performed for longer series.
- TRIM
- Share the implementation of filter in C++ and python using virtual function ovverride?
- Uniform naming scheme in C++ and python.
- Use wrappers everywhere for the exposition of functionality in python.
- tc class --> see if it is effective to perform the evaluations in C++ (possibly using parallelization), then applying the
  function in python using numpy (supposedly fast) array classes.
- Watch out for trim! We do not want to ever get it called into the anonymous interface, because it could mess up badly
  the relation with the provided args_tuple. Make sure that the named interface is _never_ used inside the anonymous one.
- maybe proxies should take an args_tuple in the ctor. This way we can avoid the cached* flags in them - Yes, but caching may
  have a non-negligible cost. Must do speed test.
- caching for lightweight coefficients in multipliers.
- speed test for hash coded implementation.
- addmul for coefficient series. This probably requires moving the ignorability check higher in the insert function stack.
- series splicing?
- uniform the naming of E/EE.
- limit for multiplication time?
- Move "using base_*" into private space of top-level series?
- Generalise conversion to/from series with arguments sets left/right shifting
- Check those complex changes and the static cast on root(y).
- Use this-> instead of ancestor:: everywhere?
- Place boost::operators in some shared toolbox?
- "GUI support was not built." or PyQt4 is not available
- Compile with -D_PIRANHA_DEBUG as default?
- memory limit: with max fast int it can only be half-1 the size of max memory, which could be a bit limiting on 32 bit.
- Remove psym interface from celmec functions.
- Another interface for Ynm, this time with theta as a complex thingie representing the complex exponential of colatitude.
- Drop all typename Derived::term_type
- %pload and %pget for series loading and symbol getting
- check that truncators do not sort if not necessary.
- for hash coded structure, use directly the counting allocator internally.
- simplify atomic counters by using a plain counter in the non-threaded case.
- handle properly the single coefficient case in series multiplication. It can give quite good performance improvement,
  especially for poisson series
- re-introduce size-hint during hash code, using density infromation
